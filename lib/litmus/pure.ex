defmodule Litmus.Pure do
  @moduledoc """
  Compile-time purity checking for Elixir code blocks.

  This module provides the `pure/1` macro that enforces purity constraints
  at compile time. Any impure function call within a `pure do ... end` block
  will result in a compilation error.

  ## Example

      import Litmus.Pure

      # This compiles successfully
      pure do
        x = [1, 2, 3]
        y = Enum.map(x, fn n -> n * 2 end)
        Enum.sum(y)
      end

      # This fails at compile time
      pure do
        IO.puts("Hello")  # ❌ Compile error: IO.puts/1 is not pure!
      end

  ## How It Works

  The macro:
  1. Analyzes the AST to extract all function calls
  2. Uses the PURITY static analyzer to check each call's purity at compile time
  3. Raises a compilation error if any impure function is found
  4. Returns the original code unchanged if all functions are pure

  ## Limitations

  - Only checks **direct function calls** in the AST
  - Cannot detect impurity from:
    - Dynamic dispatch (`apply/3`, `&Module.func/arity`)
    - Functions passed as variables
    - Code generated by other macros (analyzed before macro expansion)
  - Requires modules to be compiled with `:debug_info` for analysis
  - Conservative: functions that cannot be analyzed are considered impure

  ## Safety Philosophy

  This macro uses the **PURITY static analyzer** to determine function purity
  at compile time. The analyzer examines the actual BEAM bytecode to determine
  if functions are pure, handle exceptions, or have side effects.

  Third-party libraries like Jason will be analyzed if they are compiled and
  available at compile time.
  """

  @doc """
  Enforces purity constraints on a code block at compile time.

  Raises a compilation error if any impure function is called within the block.

  ## Options

    - `:level` - The purity level to enforce (default: `:pure`)
      - `:pure` - Only strictly pure functions (no exceptions, no side effects)
      - `:exceptions` - Pure and exception-raising functions allowed
      - `:dependent` - Pure, exceptions, and environment-dependent allowed
      - `:nif` - Pure, exceptions, dependent, and NIF functions allowed (behavior unknown)
      - `:side_effects` - Everything allowed including I/O and state mutation (disables checking)

    **Note:** NIFs are a distinct level between `:dependent` and `:side_effects` because
    while we cannot analyze their native code, they may be computationally pure but are
    conservatively treated as potentially impure.

    - `:require_termination` - Require all functions to terminate (default: `false`)
      - `true` - Only functions guaranteed to terminate are allowed
      - `false` - Non-terminating functions allowed (default)

    - `:allow_exceptions` - Control which exceptions are allowed (default: not checked)
      - `:none` - No exceptions allowed
      - `:any` - Any exceptions allowed
      - `[ExceptionModule, ...]` - Only specific exception modules allowed (e.g., `[ArgumentError, KeyError]`)
      - Note: Exception checking is ONLY enabled when this option is explicitly specified
      - Note: This is independent of `:level` - you can have `level: :pure` and still allow specific exceptions

  ## Examples

      import Litmus.Pure

      # Strict pure (default) - only pure functions
      result = pure do
        list = [1, 2, 3, 4, 5]
        list
        |> Enum.map(&(&1 * 2))
        |> Enum.filter(&(&1 > 5))
        |> Enum.sum()
      end

      # Allow functions that may raise exceptions
      result = pure level: :exceptions do
        Integer.parse("123")  # Can raise, but no side effects
      end

      # Allow environment-dependent functions
      result = pure level: :dependent do
        # Functions that depend on system state but have no side effects
      end

      # Require termination - reject functions that may run forever
      result = pure require_termination: true do
        Enum.map([1, 2, 3], &(&1 * 2))  # ✓ Terminates
        # Stream.cycle([1, 2])           # ❌ May not terminate!
      end

      # Combine options
      result = pure level: :exceptions, require_termination: true do
        Integer.parse("123")  # ✓ May raise but terminates
      end

      # Allow specific exceptions only
      result = pure allow_exceptions: [ArgumentError] do
        String.to_integer!("123")  # ✓ Can raise ArgumentError
        # Map.fetch!(%{}, :key)    # ❌ Would fail - raises KeyError!
      end

      # Allow multiple specific exceptions
      result = pure allow_exceptions: [ArgumentError, KeyError] do
        String.to_integer!("123")  # ✓ ArgumentError allowed
        Map.fetch!(%{a: 1}, :a)    # ✓ KeyError allowed
      end

      # Impure code fails at compile time
      pure do
        file_contents = File.read!("data.txt")  # ❌ Compile error!
        String.upcase(file_contents)
      end

  ## Error Messages

  When impure functions are detected, you'll see:

      ** (Litmus.ImpurityError) Impure function call detected: IO.puts/1

      The following function is not pure:
        - IO.puts/1 (level: :side_effects, required: :pure)

      Pure blocks can only call functions analyzed as pure by the PURITY analyzer.

  ## Parameters

    - `opts` - Keyword list of options (`:level`)
    - `block` - The code block to validate for purity

  ## Returns

  Returns the result of evaluating the block if all functions meet the purity level.
  Raises `Litmus.ImpurityError` at compile time if impure functions are found.
  """
  defmacro pure(opts \\ [], do: block) do
    # Get the required purity level (default: :pure)
    level = Keyword.get(opts, :level, :pure)
    require_termination = Keyword.get(opts, :require_termination, false)

    # Get exception allowance settings and evaluate at compile time
    # Note: exception checking is ONLY enabled when explicitly specified
    allow_exceptions = case Keyword.fetch(opts, :allow_exceptions) do
      {:ok, value} ->
        # Evaluate the AST to get the actual value
        {evaluated, _} = Code.eval_quoted(value, [], __CALLER__)
        evaluated

      :error ->
        # Default: disable exception checking (nil means don't check)
        nil
    end

    # Expand all macros first to get the real function calls
    expanded_block = Macro.expand(block, __CALLER__)

    # Extract all function calls from the expanded AST
    calls = extract_function_calls(expanded_block)

    # Check each call for purity using PURITY analyzer
    impure_calls = Enum.filter(calls, fn {module, _function, _arity} = call ->
      not check_purity_with_analyzer(call, module, level)
    end)

    # Check each call for termination if required
    non_terminating_calls = if require_termination do
      Enum.filter(calls, fn {module, _function, _arity} = call ->
        not check_termination_with_analyzer(call, module)
      end)
    else
      []
    end

    # Check each call for disallowed exceptions (only if explicitly enabled)
    exception_violations = if allow_exceptions != nil and allow_exceptions != :any do
      Enum.filter(calls, fn {module, _function, _arity} = call ->
        not check_exceptions_allowed(call, module, allow_exceptions)
      end)
    else
      []
    end

    # Raise compile error if any violations found
    cond do
      impure_calls != [] and non_terminating_calls != [] and exception_violations != [] ->
        raise_all_errors(impure_calls, non_terminating_calls, exception_violations, level, allow_exceptions, __CALLER__)

      impure_calls != [] and exception_violations != [] ->
        raise_purity_and_exception_error(impure_calls, exception_violations, level, allow_exceptions, __CALLER__)

      impure_calls != [] and non_terminating_calls != [] ->
        raise_combined_error(impure_calls, non_terminating_calls, level, __CALLER__)

      impure_calls != [] ->
        raise_impurity_error(impure_calls, level, __CALLER__)

      non_terminating_calls != [] ->
        raise_termination_error(non_terminating_calls, __CALLER__)

      exception_violations != [] ->
        raise_exception_error(exception_violations, allow_exceptions, __CALLER__)

      true ->
        :ok
    end

    # Return the original block unchanged
    block
  end

  # Exception raised when impure code is detected
  defmodule ImpurityError do
    defexception [:message]
  end

  ## Private Functions

  # Check if a function is pure using whitelist + PURITY analyzer
  # Strategy:
  # 1. For stdlib modules: ONLY trust the whitelist (whitelist approach)
  # 2. For known impure stdlib modules: reject (they use NIFs)
  # 3. For third-party modules: use PURITY analyzer
  defp check_purity_with_analyzer({_module, _function, _arity} = mfa, module, required_level) do
    cond do
      # Check if in stdlib whitelist
      Litmus.Stdlib.get_module_whitelist(module) != nil ->
        # Whitelisted stdlib module: check if specific function is whitelisted
        case Litmus.Stdlib.get_purity_level(mfa) do
          nil -> false  # Not whitelisted = impure
          actual_level -> meets_purity_level?(actual_level, required_level)
        end

      # Check if it's a known impure stdlib module
      is_known_impure_stdlib?(module) ->
        false

      # Third-party module: use PURITY analyzer
      true ->
        try do
          case Litmus.analyze_module(module) do
            {:ok, results} ->
              case Map.get(results, mfa) do
                nil -> false
                actual_level -> meets_purity_level?(actual_level, required_level)
              end

            {:error, _reason} ->
              false
          end
        rescue
          _ -> false
        end
    end
  end

  # Known impure Elixir stdlib modules that use NIFs or have side effects
  # These should NEVER be analyzed, always rejected
  defp is_known_impure_stdlib?(module) do
    module in [
      IO, File, Port,                        # I/O operations (use NIFs)
      Logger,                                # Logging operations (side effects)
      Process, Agent, Task, GenServer,       # Process operations
      Registry, DynamicSupervisor, Supervisor, # Supervision
      System, Node, Code, Application        # System operations
    ]
  end

  # Check if a function terminates using stdlib whitelist with PURITY analyzer fallback
  # Strategy: Trust stdlib whitelist first (it knows about lazy streams, etc.)
  # Only use PURITY analyzer for third-party code
  defp check_termination_with_analyzer({_module, _function, _arity} = mfa, module) do
    # Check if stdlib has explicit knowledge about this function
    case Litmus.Stdlib.get_termination(mfa) do
      :terminating -> true
      :non_terminating -> false
      nil ->
        # Stdlib doesn't know, try PURITY analyzer
        try do
          case Litmus.analyze_termination(module) do
            {:ok, results} ->
              case Map.get(results, mfa) do
                :terminating -> true
                :non_terminating -> false
                nil -> true  # Conservative: assume terminates if not found
              end

            {:error, _reason} ->
              # Can't analyze, assume terminates (conservative)
              true
          end
        rescue
          # If PURITY crashes, assume terminates (conservative)
          _ -> true
        end
    end
  end

  # Check if actual purity level meets the required level
  defp meets_purity_level?(actual, required) do
    level_order = [:pure, :exceptions, :dependent, :nif, :side_effects]
    actual_idx = Enum.find_index(level_order, &(&1 == actual))
    required_idx = Enum.find_index(level_order, &(&1 == required))

    actual_idx != nil and required_idx != nil and actual_idx <= required_idx
  end

  # Check if a function's exceptions are allowed
  defp check_exceptions_allowed({_module, _function, _arity} = mfa, module, allow_exceptions) do
    case allow_exceptions do
      :none ->
        # No exceptions allowed - function must not raise any exceptions
        case get_exception_info_with_fallback(mfa, module) do
          nil ->
            # No exception info available
            # Trust stdlib whitelist: if it's whitelisted as pure, allow it
            if Litmus.Stdlib.whitelisted?(mfa) do
              true
            else
              # Not whitelisted and can't determine exceptions - be conservative and reject
              false
            end

          info ->
            # Have exception info - check if pure (no exceptions)
            # Special case: if errors are :unknown but function is stdlib-whitelisted, trust the whitelist
            if info.errors == :unknown and Litmus.Stdlib.whitelisted?(mfa) do
              true
            else
              Litmus.Exceptions.pure?(info)
            end
        end

      :any ->
        # Any exceptions allowed
        true

      allowed_list when is_list(allowed_list) ->
        # Only specific exceptions allowed
        case get_exception_info_with_fallback(mfa, module) do
          nil ->
            # No exception info available
            # Trust stdlib whitelist: if it's whitelisted, allow it
            # (assume it's pure and has no exceptions)
            if Litmus.Stdlib.whitelisted?(mfa) do
              true
            else
              # Not whitelisted and can't determine exceptions - be conservative and reject
              false
            end

          info ->
            # Have exception info - check if all exceptions are in the allowed list
            # Special case: if errors are :unknown but function is stdlib-whitelisted, trust the whitelist
            if info.errors == :unknown and Litmus.Stdlib.whitelisted?(mfa) do
              true
            else
              check_exceptions_in_allowed_list(info, allowed_list)
            end
        end
    end
  end

  # Get exception info from stdlib whitelist or analyze module
  defp get_exception_info_with_fallback(mfa, module) do
    # Try stdlib whitelist first
    case Litmus.Stdlib.get_exception_info(mfa) do
      nil ->
        # Not in stdlib, try analyzing the module
        try do
          case Litmus.analyze_exceptions(module) do
            {:ok, results} -> Map.get(results, mfa)
            {:error, _reason} -> nil
          end
        rescue
          _ -> nil
        end

      info ->
        info
    end
  end

  # Check if all exceptions in info are in the allowed list
  defp check_exceptions_in_allowed_list(info, allowed_list) do
    case info.errors do
      :unknown ->
        # Unknown exceptions - can't verify, so reject
        false

      error_set ->
        # Check if function can throw/exit (non_errors)
        if info.non_errors do
          # Throw/exit not allowed in specific exception list
          false
        else
          # Check if all error modules are in allowed list
          allowed_set = MapSet.new(allowed_list)
          MapSet.subset?(error_set, allowed_set)
        end
    end
  end

  # Extract all function calls from an AST node
  defp extract_function_calls(ast) do
    {_ast, calls} =
      Macro.prewalk(ast, [], fn node, acc ->
        case extract_call(node) do
          nil -> {node, acc}
          call -> {node, [call | acc]}
        end
      end)

    Enum.uniq(calls)
  end

  # Extract MFA from a function call node
  defp extract_call({{:., _meta1, [module_alias, function]}, _meta2, args})
       when is_atom(function) and is_list(args) do
    # Remote call: Module.function(args)
    module = expand_alias(module_alias)

    if is_atom(module) do
      {module, function, length(args)}
    else
      nil
    end
  end

  defp extract_call({{:., _meta, [module_alias, function]}, _meta2, args})
       when is_atom(function) and is_atom(args) do
    # Captured function: &Module.function/arity
    module = expand_alias(module_alias)

    if is_atom(module) and is_atom(args) do
      # Note: We can't determine arity from capture syntax in AST
      # So we skip these for now (too conservative would block all captures)
      nil
    else
      nil
    end
  end

  defp extract_call({function, _meta, args})
       when is_atom(function) and is_list(args) do
    # Local call or imported function: function(args)
    # Assume it's a Kernel function if not qualified
    {Kernel, function, length(args)}
  end

  defp extract_call(_node), do: nil

  # Expand alias to actual module name
  defp expand_alias({:__aliases__, _meta, module_parts}) do
    Module.concat(module_parts)
  end

  defp expand_alias(module) when is_atom(module), do: module
  defp expand_alias(_), do: nil

  # Raise a detailed compile error about impure functions
  defp raise_impurity_error(impure_calls, level, caller) do
    level_desc = case level do
      :pure -> "strictly pure (no exceptions, no side effects)"
      :exceptions -> "pure or exception-raising (no side effects)"
      :dependent -> "pure, exception-raising, or environment-dependent (no side effects)"
      :nif -> "pure, exception-raising, environment-dependent, or NIF functions"
      :side_effects -> "any level"
    end

    formatted_calls =
      impure_calls
      |> Enum.map(fn {m, f, a} = mfa ->
        actual_level = Litmus.Stdlib.get_purity_level(mfa)
        reason = classify_impurity(m, f, a, actual_level, level)
        "  - #{inspect(m)}.#{f}/#{a}#{reason}"
      end)
      |> Enum.join("\n")

    message = """
    Impure function calls detected in pure block (level: #{inspect(level)}):

    #{formatted_calls}

    Required level: #{level_desc}
    Functions are analyzed using the PURITY static analyzer at compile time.

    Location: #{caller.file}:#{caller.line}
    """

    raise ImpurityError, message: message
  end

  # Classify why a function is impure or doesn't meet the level
  defp classify_impurity(module, function, arity, _actual_level_unused, required_level) do
    mfa = {module, function, arity}

    cond do
      # Check if in stdlib whitelist
      Litmus.Stdlib.get_module_whitelist(module) != nil ->
        " (not whitelisted in stdlib)"

      # Check if it's a known impure stdlib module
      is_known_impure_stdlib?(module) ->
        " (I/O operation)"

      # Third-party module - try to analyze
      true ->
        try do
          case Litmus.analyze_module(module) do
            {:ok, results} ->
              case Map.get(results, mfa) do
                nil ->
                  " (not found in analysis)"

                actual_level ->
                  " (analyzed: #{inspect(actual_level)}, required: #{inspect(required_level)})"
              end

            {:error, _reason} ->
              " (cannot analyze module)"
          end
        rescue
          _ -> " (analysis failed)"
        end
    end
  end

  # Raise a detailed compile error about non-terminating functions
  defp raise_termination_error(non_terminating_calls, caller) do
    formatted_calls =
      non_terminating_calls
      |> Enum.map(fn {m, f, a} ->
        reason = classify_non_termination(m, f, a)
        "  - #{inspect(m)}.#{f}/#{a}#{reason}"
      end)
      |> Enum.join("\n")

    message = """
    Non-terminating function calls detected in pure block with require_termination: true:

    #{formatted_calls}

    These functions may run forever (infinite loops, blocking I/O, etc.).
    Pure blocks with require_termination: true can only call functions guaranteed to terminate.

    Location: #{caller.file}:#{caller.line}
    """

    raise ImpurityError, message: message
  end

  # Raise combined error for both purity and termination violations
  defp raise_combined_error(impure_calls, non_terminating_calls, level, caller) do
    level_desc = case level do
      :pure -> "strictly pure (no exceptions, no side effects)"
      :exceptions -> "pure or exception-raising (no side effects)"
      :dependent -> "pure, exception-raising, or environment-dependent (no side effects)"
      :nif -> "pure, exception-raising, environment-dependent, or NIF functions"
      :side_effects -> "any level"
    end

    impure_formatted =
      impure_calls
      |> Enum.map(fn {m, f, a} = mfa ->
        actual_level = Litmus.Stdlib.get_purity_level(mfa)
        reason = classify_impurity(m, f, a, actual_level, level)
        "  - #{inspect(m)}.#{f}/#{a}#{reason}"
      end)
      |> Enum.join("\n")

    non_term_formatted =
      non_terminating_calls
      |> Enum.map(fn {m, f, a} ->
        reason = classify_non_termination(m, f, a)
        "  - #{inspect(m)}.#{f}/#{a}#{reason}"
      end)
      |> Enum.join("\n")

    message = """
    Multiple violations detected in pure block:

    IMPURE FUNCTION CALLS (level: #{inspect(level)}):
    #{impure_formatted}

    NON-TERMINATING FUNCTION CALLS:
    #{non_term_formatted}

    Required purity level: #{level_desc}
    Required termination: all functions must terminate

    Location: #{caller.file}:#{caller.line}
    """

    raise ImpurityError, message: message
  end

  # Classify why a function may not terminate
  defp classify_non_termination(module, function, _arity) do
    cond do
      module == Stream and function in [:cycle, :iterate, :repeatedly, :unfold, :resource] ->
        " (infinite generator)"

      module == Process and function in [:sleep, :hibernate] ->
        " (blocking process operation)"

      module in [GenServer, Agent, Task] ->
        " (may block indefinitely)"

      true ->
        " (may not terminate)"
    end
  end

  # Raise a detailed compile error about disallowed exceptions
  defp raise_exception_error(exception_violations, allow_exceptions, caller) do
    formatted_calls =
      exception_violations
      |> Enum.map(fn {m, f, a} = mfa ->
        info = get_exception_info_with_fallback(mfa, m)
        reason = classify_exception_violation(info, allow_exceptions)
        "  - #{inspect(m)}.#{f}/#{a}#{reason}"
      end)
      |> Enum.join("\n")

    allowed_desc = case allow_exceptions do
      :none -> "no exceptions"
      :any -> "any exceptions"
      list when is_list(list) -> "only #{inspect(list)}"
    end

    message = """
    Disallowed exception calls detected in pure block:

    #{formatted_calls}

    Allowed exceptions: #{allowed_desc}
    Functions with disallowed exceptions cannot be used in this pure block.

    Location: #{caller.file}:#{caller.line}
    """

    raise ImpurityError, message: message
  end

  # Classify why an exception is disallowed
  defp classify_exception_violation(nil, _allow_exceptions) do
    " (cannot determine exceptions)"
  end

  defp classify_exception_violation(info, allow_exceptions) do
    case info.errors do
      :unknown ->
        " (raises unknown exceptions)"

      error_set when allow_exceptions == :none ->
        errors = error_set |> MapSet.to_list() |> Enum.map(&inspect/1) |> Enum.join(", ")
        throws = if info.non_errors, do: ", throw/exit", else: ""
        " (raises: #{errors}#{throws})"

      error_set when is_list(allow_exceptions) ->
        disallowed = MapSet.difference(error_set, MapSet.new(allow_exceptions))
        disallowed_list = disallowed |> MapSet.to_list() |> Enum.map(&inspect/1) |> Enum.join(", ")

        cond do
          info.non_errors ->
            " (raises: #{disallowed_list}, throw/exit not allowed)"

          MapSet.size(disallowed) > 0 ->
            " (raises disallowed: #{disallowed_list})"

          true ->
            " (unknown violation)"
        end
    end
  end

  # Raise combined error for purity and exception violations
  defp raise_purity_and_exception_error(impure_calls, exception_violations, level, allow_exceptions, caller) do
    level_desc = case level do
      :pure -> "strictly pure (no exceptions, no side effects)"
      :exceptions -> "pure or exception-raising (no side effects)"
      :dependent -> "pure, exception-raising, or environment-dependent (no side effects)"
      :nif -> "pure, exception-raising, environment-dependent, or NIF functions"
      :side_effects -> "any level"
    end

    allowed_desc = case allow_exceptions do
      :none -> "no exceptions"
      :any -> "any exceptions"
      list when is_list(list) -> "only #{inspect(list)}"
    end

    impure_formatted =
      impure_calls
      |> Enum.map(fn {m, f, a} = mfa ->
        actual_level = Litmus.Stdlib.get_purity_level(mfa)
        reason = classify_impurity(m, f, a, actual_level, level)
        "  - #{inspect(m)}.#{f}/#{a}#{reason}"
      end)
      |> Enum.join("\n")

    exception_formatted =
      exception_violations
      |> Enum.map(fn {m, f, a} = mfa ->
        info = get_exception_info_with_fallback(mfa, m)
        reason = classify_exception_violation(info, allow_exceptions)
        "  - #{inspect(m)}.#{f}/#{a}#{reason}"
      end)
      |> Enum.join("\n")

    message = """
    Multiple violations detected in pure block:

    IMPURE FUNCTION CALLS (level: #{inspect(level)}):
    #{impure_formatted}

    DISALLOWED EXCEPTION CALLS:
    #{exception_formatted}

    Required purity level: #{level_desc}
    Allowed exceptions: #{allowed_desc}

    Location: #{caller.file}:#{caller.line}
    """

    raise ImpurityError, message: message
  end

  # Raise combined error for all three types of violations
  defp raise_all_errors(impure_calls, non_terminating_calls, exception_violations, level, allow_exceptions, caller) do
    level_desc = case level do
      :pure -> "strictly pure (no exceptions, no side effects)"
      :exceptions -> "pure or exception-raising (no side effects)"
      :dependent -> "pure, exception-raising, or environment-dependent (no side effects)"
      :nif -> "pure, exception-raising, environment-dependent, or NIF functions"
      :side_effects -> "any level"
    end

    allowed_desc = case allow_exceptions do
      :none -> "no exceptions"
      :any -> "any exceptions"
      list when is_list(list) -> "only #{inspect(list)}"
    end

    impure_formatted =
      impure_calls
      |> Enum.map(fn {m, f, a} = mfa ->
        actual_level = Litmus.Stdlib.get_purity_level(mfa)
        reason = classify_impurity(m, f, a, actual_level, level)
        "  - #{inspect(m)}.#{f}/#{a}#{reason}"
      end)
      |> Enum.join("\n")

    non_term_formatted =
      non_terminating_calls
      |> Enum.map(fn {m, f, a} ->
        reason = classify_non_termination(m, f, a)
        "  - #{inspect(m)}.#{f}/#{a}#{reason}"
      end)
      |> Enum.join("\n")

    exception_formatted =
      exception_violations
      |> Enum.map(fn {m, f, a} = mfa ->
        info = get_exception_info_with_fallback(mfa, m)
        reason = classify_exception_violation(info, allow_exceptions)
        "  - #{inspect(m)}.#{f}/#{a}#{reason}"
      end)
      |> Enum.join("\n")

    message = """
    Multiple violations detected in pure block:

    IMPURE FUNCTION CALLS (level: #{inspect(level)}):
    #{impure_formatted}

    NON-TERMINATING FUNCTION CALLS:
    #{non_term_formatted}

    DISALLOWED EXCEPTION CALLS:
    #{exception_formatted}

    Required purity level: #{level_desc}
    Required termination: all functions must terminate
    Allowed exceptions: #{allowed_desc}

    Location: #{caller.file}:#{caller.line}
    """

    raise ImpurityError, message: message
  end

  @doc """
  Checks if a code block is pure without raising an error.

  Returns `{:ok, calls}` if pure, or `{:error, impure_calls}` if impure.

  This is useful for conditional checking or building tools that need
  to query purity without failing compilation.

  **Note**: This function analyzes the AST as-is without macro expansion.
  For accurate results with macros like `|>`, use the `pure/1` macro instead.

  ## Example

      import Litmus.Pure

      case check_purity(quote do
        Enum.map([1, 2, 3], &(&1 * 2))
      end) do
        {:ok, _calls} ->
          IO.puts("Code is pure!")

        {:error, impure} ->
          IO.puts("Found impure calls: \#{inspect(impure)}")
      end
  """
  def check_purity(ast, env \\ nil) do
    # Expand macros if environment is provided
    expanded_ast = if env, do: Macro.expand(ast, env), else: ast
    calls = extract_function_calls(expanded_ast)

    impure_calls = Enum.filter(calls, fn call ->
      not Litmus.Stdlib.whitelisted?(call)
    end)

    if impure_calls == [] do
      {:ok, calls}
    else
      {:error, impure_calls}
    end
  end

  @doc """
  Lists all function calls in a code block.

  Returns a list of `{module, function, arity}` tuples found in the AST.

  **Note**: This function analyzes the AST as-is without macro expansion.
  Macros like `|>` won't be expanded, so arities may not match the actual calls.

  ## Example

      import Litmus.Pure

      calls = list_calls(quote do
        x = Enum.map([1, 2, 3], fn n -> n * 2 end)
        String.upcase("hello")
      end)

      # Returns: [{Enum, :map, 2}, {String, :upcase, 1}]
  """
  def list_calls(ast, env \\ nil) do
    # Expand macros if environment is provided
    expanded_ast = if env, do: Macro.expand(ast, env), else: ast
    extract_function_calls(expanded_ast)
  end
end
