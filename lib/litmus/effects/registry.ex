defmodule Litmus.Effects.Registry do
  @moduledoc """
  Registry of known side-effectful functions in Elixir and Erlang standard libraries.

  This module tracks which functions have side effects and should be intercepted
  during effect handling. It loads effect information from multiple sources at compile time:

  1. `.effects.json` - Standard library effects (Elixir & Erlang stdlib)
  2. `.effects/generated` - Application module effects (generated by `mix generate_effects`)
  3. `.effects/deps` - Dependency module effects (optional)

  ## IMPORTANT: Standard Library Completeness

  All functions from Elixir and Erlang standard libraries MUST be explicitly defined
  in `.effects.json`. If a stdlib function is queried but not found in the registry,
  this module will raise an exception immediately rather than returning `:unknown`.

  This ensures completeness of effect tracking for all standard library functions.

  ## Application Modules

  Application modules should have their effects generated using `mix generate_effects`.
  This creates `.effects/generated` file with inferred effects for your application code.
  """

  # Load effects from JSON at compile time
  @effects_path Path.join(__DIR__, "../../../.effects.json")
  @external_resource @effects_path

  # Load additional effect files from .effects/ directory
  @effects_generated_path Path.join(__DIR__, "../../../.effects/generated")
  @effects_deps_path Path.join(__DIR__, "../../../.effects/deps")

  # Load stdlib effects
  stdlib_effects = @effects_path |> File.read!() |> Jason.decode!()

  # Load generated effects (application modules)
  generated_effects = if File.exists?(@effects_generated_path) do
    @effects_generated_path |> File.read!() |> Jason.decode!()
  else
    %{}
  end

  # Load dependency effects
  deps_effects = if File.exists?(@effects_deps_path) do
    @effects_deps_path |> File.read!() |> Jason.decode!()
  else
    %{}
  end

  # Merge all effect sources (later sources override earlier ones)
  effects_data = Map.merge(Map.merge(stdlib_effects, generated_effects), deps_effects)

  # Build a map of {module, function, arity} => effect_type
  @effects_map effects_data
    |> Enum.reject(fn {key, _} -> String.starts_with?(key, "_") end)
    |> Enum.flat_map(fn {module_name, functions} ->
      # Convert module name string to atom
      module = case module_name do
        "Elixir." <> rest -> Module.concat([rest])
        name -> String.to_atom(name)
      end

      # Convert each function entry
      Enum.map(functions, fn {func_arity, effect} ->
        # Parse "function/arity" - find the LAST "/" to handle operators like "..", "//", etc.
        case String.reverse(func_arity) |> String.split("/", parts: 2) do
          [reversed_arity, reversed_name] ->
            func_name = String.reverse(reversed_name)
            arity_str = String.reverse(reversed_arity)
            func_atom = String.to_atom(func_name)
            arity = String.to_integer(arity_str)

            {{module, func_atom, arity}, effect}

          _ ->
            raise "Invalid function/arity format: #{func_arity}"
        end
      end)
    end)
    |> Map.new()

  # Extract unique modules
  @effect_modules effects_data
    |> Map.keys()
    |> Enum.reject(&String.starts_with?(&1, "_"))
    |> Enum.map(fn
      "Elixir." <> rest -> Module.concat([rest])
      name -> String.to_atom(name)
    end)
    |> Enum.uniq()

  # Standard library modules that MUST be fully covered in the registry
  # Any function from these modules MUST have an explicit effect definition
  # This list includes all Elixir and Erlang stdlib modules from a bare iex session
  @elixir_stdlib_modules [
    # Core data structures (mostly pure)
    Access, Atom, Base, Bitwise, Date, DateTime, Duration, Enum, Float, Function,
    Integer, Keyword, List, Map, MapSet, NaiveDateTime, Range, Regex, Stream, String,
    StringIO, Time, Tuple, URI, Version,

    # I/O and File operations (side effects)
    File, File.Stat, File.Stream, IO, IO.ANSI, IO.Stream,

    # Process and concurrency (side effects)
    Agent, Application, Code, DynamicSupervisor, GenEvent, GenServer, Node,
    PartitionSupervisor, Port, Process, Registry, Supervisor, Task, Task.Supervisor,

    # System operations (side effects)
    Logger, System,

    # Special modules
    Kernel, Kernel.SpecialForms,

    # Metaprogramming
    Macro, Macro.Env, Module,

    # Utilities
    Calendar, Config, Exception, Inspect, OptionParser, Path, Protocol, Record
  ]

  @erlang_stdlib_modules [
    # Core Erlang modules
    :erlang, :lists, :maps, :sets, :ordsets, :orddict, :sofs,
    :gb_sets, :gb_trees, :queue, :proplists, :string, :binary, :unicode, :re,

    # I/O and File
    :file, :filename, :io, :prim_file,

    # Network
    :inet, :inet_db, :inet_parse, :gen_tcp, :gen_udp, :ssl,

    # Processes and OTP
    :gen_server, :gen_event, :supervisor, :proc_lib, :sys, :application,

    # ETS and persistence
    :ets, :dets, :persistent_term, :atomics, :counters,

    # Random and crypto
    :rand, :random,

    # System
    :os, :init, :code, :error_logger, :logger,

    # Compression
    :zlib,

    # RPC
    :rpc, :global, :global_group,

    # Runtime
    :erts_internal, :erl_eval, :erl_scan, :erl_parse
  ]

  @stdlib_modules @elixir_stdlib_modules ++ @erlang_stdlib_modules

  defmodule MissingStdlibEffectError do
    defexception [:message, :mfa]

    @impl true
    def exception({module, function, arity}) do
      message = """
      Standard library function #{inspect(module)}.#{function}/#{arity} is not defined in the effects registry.

      All Elixir and Erlang standard library functions MUST be explicitly defined in .effects.json.

      To fix this:
      1. Add the function to .effects.json with its correct effect type:
         - "p" (pure) - referentially transparent, no side effects
         - "d" (dependent) - depends on execution environment
         - "n" (NIF) - native code, behavior unknown
         - "s" (stateful) - writes/modifies state
         - "l" (lambda) - may inherit effects from passed functions
         - "u" (unknown) - cannot be analyzed
         - {"e", [types]} - may raise specific exceptions
      2. If this is a pure function from Kernel, add it to the registry as "p"
      3. If this function should be tracked, determine its effect and add it

      This is a critical error to ensure completeness of effect tracking.
      """

      %__MODULE__{message: message, mfa: {module, function, arity}}
    end
  end

  @doc """
  Checks if an MFA is from a standard library module.

  Standard library modules MUST have complete effect coverage in the registry.
  """
  def stdlib_function?({module, _function, _arity}) do
    module in @stdlib_modules
  end

  @doc """
  Returns true if the given MFA (module, function, arity) is a known effect.

  This uses the effect registry loaded from `.effects.json` at compile time.

  ## Raises

  Raises `MissingStdlibEffectError` if the MFA is from a standard library
  module but is not defined in the registry.
  """
  def effect?(mfa) do
    has_effect = Map.has_key?(@effects_map, mfa)

    # If not found and it's a stdlib function, raise an error
    if not has_effect and stdlib_function?(mfa) do
      raise MissingStdlibEffectError, mfa
    end

    has_effect
  end

  @doc """
  Returns the effect type for a given MFA.

  Returns one of:
  - `:p` - pure (no effects)
  - `:d` - dependent (reads from execution environment)
  - `:l` - lambda (effects depend on passed lambdas)
  - `:n` - nif
  - `:exn` - can raise exceptions
  - `:s` - side effects (io, file, process, network, state, etc.)
  - `:u` - unknown
  - `nil` - not in registry (only for non-stdlib functions)

  ## Raises

  Raises `MissingStdlibEffectError` if the MFA is from a standard library
  module but is not defined in the registry.

  ## Examples

      iex> effect_type({File, :read!, 1})
      :s

      iex> effect_type({Kernel, :hd, 1})
      :exn

      # Non-stdlib function not in registry returns nil
      iex> effect_type({MyApp.CustomModule, :foo, 1})
      nil

      # Stdlib function not in registry raises
      iex> effect_type({File, :undefined_function, 99})
      ** (Litmus.Effects.Registry.MissingStdlibEffectError) ...
  """
  def effect_type(mfa) do
    case Map.get(@effects_map, mfa) do
      nil ->
        # Check runtime cache first (for cross-module analysis)
        case Map.get(runtime_cache(), mfa) do
          nil ->
            # If it's a stdlib function and not in registry, this is an error
            # UNLESS we're in permissive mode (during registry generation)
            if stdlib_function?(mfa) and not permissive_mode?() do
              raise MissingStdlibEffectError, mfa
            end
            nil

          # Runtime cache stores compact effects (atoms/tuples), return directly
          cached_effect when is_atom(cached_effect) or is_tuple(cached_effect) ->
            cached_effect
        end

      # JSON format from .effects.json (strings and maps)
      "p" -> :p
      "d" -> :d
      "l" -> :l
      "n" -> :n
      "s" -> :s
      "u" -> :u
      %{"e" => ["exn"]} -> :exn
      %{"e" => _} -> :exn
      _ -> :u
    end
  end

  @doc """
  Enables permissive mode where missing stdlib functions return nil instead of raising.
  This is used during registry generation to avoid circular dependency issues.
  """
  def set_permissive_mode(enabled) do
    Process.put(:litmus_registry_permissive, enabled)
  end

  defp permissive_mode?() do
    Process.get(:litmus_registry_permissive, false)
  end

  @doc """
  Sets a runtime effect cache for dynamically analyzed modules.
  This allows mix effect to analyze multiple files and use results across modules.

  Cache format: %{{module, function, arity} => effect_type}
  """
  def set_runtime_cache(cache) when is_map(cache) do
    Process.put(:litmus_runtime_effects_cache, cache)
  end

  @doc """
  Clears the runtime effect cache.
  """
  def clear_runtime_cache() do
    Process.delete(:litmus_runtime_effects_cache)
  end

  defp runtime_cache() do
    Process.get(:litmus_runtime_effects_cache, %{})
  end

  @doc """
  Returns the effect category for a given MFA.

  This is a legacy function that maps effect types to more specific categories.
  For new code, use `effect_type/1` instead.

  Categories:
  - `:exception` - Can raise exceptions
  - `:dependent` - Reads from execution environment (time, process dict, env vars, ETS)
  - `:lambda` - Effects depend on passed lambdas/higher-order functions
  - `:side_effects` - Has side effects (I/O, file, process, network, state, etc.)
  - `:nif` - Native implemented functions
  - `:unknown` - Unknown or unclassified effects
  - `:pure` - Pure function (no effects)
  """
  def effect_category(mfa) do
    case effect_type(mfa) do
      :p -> :pure
      :d -> :dependent
      :l -> :lambda
      :n -> :nif
      :exn -> :exception
      :s -> :side_effects
      :u -> :unknown
      nil -> :unknown
    end
  end

  @doc """
  Returns a list of all registered effect modules.
  """
  def effect_modules do
    @effect_modules
  end

  @doc """
  Checks if a module is known to contain effects.
  """
  def effect_module?(module) do
    module in @effect_modules
  end

  @doc """
  Returns all MFAs in the effect registry.
  """
  def all_effects do
    Map.keys(@effects_map)
  end

  @doc """
  Returns the raw effects map loaded from .effects.json.

  This is useful for debugging or advanced use cases.
  """
  def effects_map do
    @effects_map
  end
end
