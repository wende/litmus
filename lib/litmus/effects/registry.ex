defmodule Litmus.Effects.Registry do
  @moduledoc """
  Registry of known side-effectful functions in Elixir and Erlang standard libraries.

  This module tracks which functions have side effects and should be intercepted
  during effect handling. It loads effect information from multiple sources at compile time:

  1. `.effects/std.json` - Standard library effects (Elixir & Erlang stdlib, auto-generated)
  2. `.effects/generated` - Application module effects (generated by `mix generate_effects`)
  3. `.effects/deps` - Dependency module effects (optional)

  ## IMPORTANT: Standard Library Completeness

  All functions from Elixir and Erlang standard libraries MUST be explicitly defined
  in `.effects/std.json`. If a stdlib function is queried but not found in the registry,
  this module will raise an exception immediately rather than returning `:unknown`.

  This ensures completeness of effect tracking for all standard library functions.

  ## Application Modules

  Application modules should have their effects generated using `mix generate_effects`.
  This creates `.effects/generated` file with inferred effects for your application code.
  """

  # Load effects from JSON at compile time
  @effects_path Path.join(__DIR__, "../../../.effects/std.json")
  @external_resource @effects_path

  # Load additional effect files from .effects/ directory
  @effects_generated_path Path.join(__DIR__, "../../../.effects/generated")
  @effects_deps_path Path.join(__DIR__, "../../../.effects/deps")

  # Note: Defer JSON loading to runtime to avoid compile-time dependency on Jason
  # These will be loaded lazily when first accessed

  defp load_stdlib_effects do
    @effects_path |> File.read!() |> Jason.decode!()
  end

  defp load_generated_effects do
    if File.exists?(@effects_generated_path) do
      @effects_generated_path |> File.read!() |> Jason.decode!()
    else
      %{}
    end
  end

  defp load_deps_effects do
    if File.exists?(@effects_deps_path) do
      @effects_deps_path |> File.read!() |> Jason.decode!()
    else
      %{}
    end
  end

  defp load_all_effects do
    stdlib_effects = load_stdlib_effects()
    generated_effects = load_generated_effects()
    deps_effects = load_deps_effects()

    # Deep merge at the function level with priority: stdlib > generated > deps
    # Stdlib has manually-reviewed effects and should override everything else
    deps_effects
    |> deep_merge_effects(generated_effects)
    |> deep_merge_effects(stdlib_effects)
  end

  # Deep merge effects maps at the function level
  defp deep_merge_effects(map1, map2) do
    Map.merge(map1, map2, fn _module, functions1, functions2 ->
      Map.merge(functions1, functions2)
    end)
  end

  # Use external_resource so recompilation happens when files change
  @external_resource @effects_path

  # Build effects map lazily at runtime (avoids compile-time Jason dependency)
  @doc """
  Returns the raw effects map loaded from .effects.json.

  This is useful for debugging or advanced use cases. Loaded lazily on first access.
  """
  def effects_map do
    case :persistent_term.get({__MODULE__, :effects_map}, nil) do
      nil ->
        effects_data = load_all_effects()

        map = effects_data
              |> Enum.reject(fn {key, _} -> String.starts_with?(key, "_") end)
              |> Enum.flat_map(fn {module_name, functions} ->
                # Convert module name string to atom
                module =
                  case module_name do
                    "Elixir." <> rest -> Module.concat([rest])
                    name -> String.to_atom(name)
                  end

                # Convert each function entry
                Enum.map(functions, fn {func_arity, effect} ->
                  # Parse "function/arity" - find the LAST "/" to handle operators like "..", "//", etc.
                  case String.reverse(func_arity) |> String.split("/", parts: 2) do
                    [reversed_arity, reversed_name] ->
                      func_name = String.reverse(reversed_name)
                      arity_str = String.reverse(reversed_arity)
                      func_atom = String.to_atom(func_name)
                      arity = String.to_integer(arity_str)

                      {{module, func_atom, arity}, effect}

                    _ ->
                      raise "Invalid function/arity format: #{func_arity}"
                  end
                end)
              end)
              |> Map.new()

        :persistent_term.put({__MODULE__, :effects_map}, map)
        map
      cached -> cached
    end
  end

  # Note: @effects_map and @effect_modules module attributes removed
  # They are now loaded lazily via effects_map() function to avoid compile-time Jason dependency

  # Standard library modules that MUST be fully covered in the registry
  # Any function from these modules MUST have an explicit effect definition
  # This list includes all Elixir and Erlang stdlib modules from a bare iex session
  @elixir_stdlib_modules [
    # Core data structures (mostly pure)
    Access,
    Atom,
    Base,
    Bitwise,
    Date,
    DateTime,
    Duration,
    Enum,
    Float,
    Function,
    Integer,
    Keyword,
    List,
    Map,
    MapSet,
    NaiveDateTime,
    Range,
    Regex,
    Stream,
    String,
    StringIO,
    Time,
    Tuple,
    URI,
    Version,

    # I/O and File operations (side effects)
    File,
    File.Stat,
    File.Stream,
    IO,
    IO.ANSI,
    IO.Stream,

    # Process and concurrency (side effects)
    Agent,
    Application,
    Code,
    DynamicSupervisor,
    GenEvent,
    GenServer,
    Node,
    PartitionSupervisor,
    Port,
    Process,
    Registry,
    Supervisor,
    Task,
    Task.Supervisor,

    # System operations (side effects)
    Logger,
    System,

    # Special modules
    Kernel,
    Kernel.SpecialForms,

    # Metaprogramming
    Macro,
    Macro.Env,
    Module,

    # Utilities
    Calendar,
    Config,
    Exception,
    Inspect,
    OptionParser,
    Path,
    Protocol,
    Record
  ]

  @erlang_stdlib_modules [
    # Core Erlang modules
    :erlang,
    :lists,
    :maps,
    :sets,
    :ordsets,
    :orddict,
    :sofs,
    :gb_sets,
    :gb_trees,
    :queue,
    :proplists,
    :string,
    :binary,
    :unicode,
    :re,

    # I/O and File
    :file,
    :filename,
    :io,
    :prim_file,

    # Network
    :inet,
    :inet_db,
    :inet_parse,
    :gen_tcp,
    :gen_udp,
    :ssl,

    # Processes and OTP
    :gen_server,
    :gen_event,
    :supervisor,
    :proc_lib,
    :sys,
    :application,

    # ETS and persistence
    :ets,
    :dets,
    :persistent_term,
    :atomics,
    :counters,

    # Random and crypto
    :rand,
    :random,

    # System
    :os,
    :init,
    :code,
    :error_logger,
    :logger,

    # Compression
    :zlib,

    # RPC
    :rpc,
    :global,
    :global_group,

    # Runtime
    :erts_internal,
    :erl_eval,
    :erl_scan,
    :erl_parse
  ]

  @stdlib_modules @elixir_stdlib_modules ++ @erlang_stdlib_modules

  defmodule MissingStdlibEffectError do
    defexception [:message, :mfa]

    @impl true
    def exception({module, function, arity}) do
      message = """
      Standard library function #{inspect(module)}.#{function}/#{arity} is not defined in the effects registry.

      All Elixir and Erlang standard library functions MUST be explicitly defined in .effects.json.

      To fix this:
      1. Add the function to .effects.json with its correct effect type:
         - "p" (pure) - referentially transparent, no side effects
         - "d" (dependent) - depends on execution environment
         - "n" (NIF) - native code, behavior unknown
         - "s" (stateful) - writes/modifies state
         - "l" (lambda) - may inherit effects from passed functions
         - "u" (unknown) - cannot be analyzed
         - {"e", [types]} - may raise specific exceptions
      2. If this is a pure function from Kernel, add it to the registry as "p"
      3. If this function should be tracked, determine its effect and add it

      This is a critical error to ensure completeness of effect tracking.
      """

      %__MODULE__{message: message, mfa: {module, function, arity}}
    end
  end

  @doc """
  Checks if an MFA is from a standard library module.

  Standard library modules MUST have complete effect coverage in the registry.
  """
  def stdlib_function?({module, _function, _arity}) do
    module in @stdlib_modules
  end

  @doc """
  Returns true if the given MFA (module, function, arity) is a known effect.

  This uses the effect registry loaded from `.effects.json` at compile time.

  ## Raises

  Raises `MissingStdlibEffectError` if the MFA is from a standard library
  module but is not defined in the registry.
  """
  def effect?(mfa) do
    has_effect = Map.has_key?(effects_map(), mfa)

    # If not found, try resolving through resolution map
    if not has_effect do
      case resolve_to_leaves(mfa) do
        # Has resolution, so it has an effect
        {:ok, _leaves} ->
          true

        :not_found ->
          # Skip special forms - they're compiled away and not tracked
          if special_form?(mfa) do
            false
            # If it's a stdlib function and not in registry or resolution, raise error
          else
            if stdlib_function?(mfa) do
              raise MissingStdlibEffectError, mfa
            end

            false
          end
      end
    else
      true
    end
  end

  @doc """
  Returns the effect type for a given MFA.

  Returns one of:
  - `:p` - pure (no effects)
  - `:d` - dependent (reads from execution environment)
  - `:l` - lambda (effects depend on passed lambdas)
  - `:n` - nif
  - `:exn` - can raise exceptions
  - `:s` - side effects (io, file, process, network, state, etc.)
  - `:u` - unknown
  - `nil` - not in registry (only for non-stdlib functions)

  ## Raises

  Raises `MissingStdlibEffectError` if the MFA is from a standard library
  module but is not defined in the registry.

  ## Examples

      iex> effect_type({File, :read!, 1})
      :s

      iex> effect_type({Kernel, :hd, 1})
      :exn

      # Non-stdlib function not in registry returns nil
      iex> effect_type({MyApp.CustomModule, :foo, 1})
      nil

      # Stdlib function not in registry raises
      iex> effect_type({File, :undefined_function, 99})
      ** (Litmus.Effects.Registry.MissingStdlibEffectError) ...
  """
  def effect_type(mfa) do
    # Check if this is Kernel.Utils.raise/1 - it's used for raising exceptions
    # and should be marked as exception effect
    if mfa == {Kernel.Utils, :raise, 1} do
      :e
      # Check if this is an exception struct construction function
      # These are generated by defexception and are always pure
      # This overrides any incorrect registry entries
    else
      if exception_struct_function?(mfa) do
        :p
      else
        case Map.get(effects_map(), mfa) do
          nil ->
            # Not in effects map - check runtime cache or return nil
            # Resolution is now handled by caller (from_mfa) to enable multi-effect tracking
            # Check runtime cache (for cross-module analysis)
            cache = runtime_cache()

            cached_effect =
              case Map.get(cache, mfa) do
                nil ->
                  # Try to resolve nested module names or local function calls
                  {module, function, arity} = mfa

                  # Strategy 1: Module basename matching
                  # If MFA is {TestHelper, :func, 1}, try to find Support.EdgeCasesTest.TestHelper.func/1
                  module_str = to_string(module)
                  module_basename = module_str |> String.split(".") |> List.last()

                  match =
                    cache
                    |> Enum.find(fn {{cached_mod, cached_fun, cached_arity}, _effect} ->
                      cached_mod_str = to_string(cached_mod)
                      cached_basename = cached_mod_str |> String.split(".") |> List.last()

                      cached_arity == arity and cached_fun == function and
                        cached_basename == module_basename
                    end)

                  case match do
                    {_mfa, effect} ->
                      effect

                    nil ->
                      # Strategy 2: For Kernel.func calls that aren't actually in Kernel,
                      # try to find ANY function with that name and arity in the cache
                      # This handles local function calls like higher_order_pure
                      if module == Kernel do
                        cache
                        |> Enum.find(fn {{_cached_mod, cached_fun, cached_arity}, _effect} ->
                          cached_fun == function and cached_arity == arity
                        end)
                        |> case do
                          {_mfa, effect} -> effect
                          nil -> nil
                        end
                      else
                        nil
                      end
                  end

                effect ->
                  effect
              end

            case cached_effect do
              nil ->
                # Check if this is an exception struct construction function
                # These are generated by defexception and are always pure
                if exception_struct_function?(mfa) do
                  :p
                  # Special forms are compile-time constructs and are always pure
                else
                  if special_form?(mfa) do
                    :p
                    # If it's a stdlib function and not in registry, check if it can be resolved
                    # Only raise error if it CANNOT be resolved and we're not in permissive mode
                  else
                    if stdlib_function?(mfa) and not permissive_mode?() do
                      # Check if it has a resolution - if so, return nil to let caller resolve
                      case resolve_to_leaves(mfa) do
                        {:ok, _leaves} ->
                          # Has resolution, return nil so caller (from_mfa) can handle it
                          nil

                        :not_found ->
                          # No resolution available, raise error
                          raise MissingStdlibEffectError, mfa
                      end
                    else
                      nil
                    end
                  end
                end

              # Runtime cache stores compact effects (atoms/tuples), return directly
              cached_effect when is_atom(cached_effect) or is_tuple(cached_effect) ->
                cached_effect
            end

          # JSON format from .effects.json (strings and maps)
          "p" ->
            :p

          "d" ->
            :d

          "l" ->
            :l

          "n" ->
            :n

          "s" ->
            :s

          "u" ->
            :u

          "e" ->
            :e

          %{"e" => ["exn"]} ->
            :exn

          %{"e" => types} ->
            # Prefix exception types with "Elixir." if not already prefixed
            prefixed_types = Enum.map(types, fn
              "Elixir." <> _ = type -> type
              type -> "Elixir.#{type}"
            end)
            {:e, prefixed_types}

          _ ->
            :u
        end
      end
    end
  end

  @doc """
  Enables permissive mode where missing stdlib functions return nil instead of raising.
  This is used during registry generation to avoid circular dependency issues.
  """
  def set_permissive_mode(enabled) do
    Process.put(:litmus_registry_permissive, enabled)
  end

  defp permissive_mode?() do
    Process.get(:litmus_registry_permissive, false)
  end

  @doc """
  Sets a runtime effect cache for dynamically analyzed modules.
  This allows mix effect to analyze multiple files and use results across modules.

  Cache format: %{{module, function, arity} => effect_type}
  """
  def set_runtime_cache(cache) when is_map(cache) do
    Process.put(:litmus_runtime_effects_cache, cache)
  end

  @doc """
  Adds a single function effect to the runtime cache.

  This allows incremental cache updates as functions are analyzed.
  """
  def add_to_runtime_cache(mfa, effect_type) do
    current_cache = runtime_cache()
    updated_cache = Map.put(current_cache, mfa, effect_type)
    set_runtime_cache(updated_cache)
  end

  @doc """
  Clears the runtime effect cache.
  """
  def clear_runtime_cache() do
    Process.delete(:litmus_runtime_effects_cache)
  end

  @doc """
  Gets the current runtime effect cache.
  """
  def runtime_cache() do
    Process.get(:litmus_runtime_effects_cache, %{})
  end

  @doc """
  Returns the effect category for a given MFA.

  This is a legacy function that maps effect types to more specific categories.
  For new code, use `effect_type/1` instead.

  Categories:
  - `:exception` - Can raise exceptions
  - `:dependent` - Reads from execution environment (time, process dict, env vars, ETS)
  - `:lambda` - Effects depend on passed lambdas/higher-order functions
  - `:side_effects` - Has side effects (I/O, file, process, network, state, etc.)
  - `:nif` - Native implemented functions
  - `:unknown` - Unknown or unclassified effects
  - `:pure` - Pure function (no effects)
  """
  def effect_category(mfa) do
    case effect_type(mfa) do
      :p -> :pure
      :d -> :dependent
      :l -> :lambda
      :n -> :nif
      :e -> :exception
      :exn -> :exception
      :s -> :side_effects
      :u -> :unknown
      nil -> :unknown
      # Handle tuple formats for detailed effect tracking
      {:p, _} -> :pure
      {:d, _} -> :dependent
      {:l, _} -> :lambda
      {:n, _} -> :nif
      {:e, _} -> :exception
      {:s, _} -> :side_effects
      {:u, _} -> :unknown
    end
  end

  @doc """
  Returns a list of all registered effect modules.
  """
  def effect_modules do
    effects_map()
    |> Map.keys()
    |> Enum.map(fn {module, _fun, _arity} -> module end)
    |> Enum.uniq()
  end

  @doc """
  Checks if a module is known to contain effects.
  """
  def effect_module?(module) do
    module in effect_modules()
  end

  @doc """
  Returns all MFAs in the effect registry.
  """
  def all_effects do
    Map.keys(effects_map())
  end

  # Load resolution mapping at compile time
  @resolution_path Path.join(__DIR__, "../../../.effects/resolution.json")
  @resolution_supplement_path Path.join(__DIR__, "../../../.effects.resolution_supplement.json")

  @resolution_map (if File.exists?(@resolution_path) do
                     resolution_data = @resolution_path |> File.read!() |> Jason.decode!()

                     # Merge with manual resolution supplement
                     resolution_data =
                       if File.exists?(@resolution_supplement_path) do
                         supplement =
                           @resolution_supplement_path |> File.read!() |> Jason.decode!()

                         Map.merge(resolution_data, supplement, fn _key, auto, manual ->
                           # Manual entries override/supplement auto
                           Map.merge(auto, manual)
                         end)
                       else
                         resolution_data
                       end

                     resolution_data
                     |> Enum.reject(fn {key, _} -> String.starts_with?(key, "_") end)
                     |> Enum.flat_map(fn {module_name, functions} ->
                       # Convert module name string to atom
                       module =
                         case module_name do
                           "Elixir." <> rest -> Module.concat([rest])
                           name -> String.to_atom(name)
                         end

                       # Convert each function resolution
                       Enum.map(functions, fn {func_arity, leaf_strs} ->
                         # Parse "function/arity"
                         case String.reverse(func_arity) |> String.split("/", parts: 2) do
                           [reversed_arity, reversed_name] ->
                             func_name = String.reverse(reversed_name)
                             arity = String.reverse(reversed_arity) |> String.to_integer()
                             func_atom = String.to_atom(func_name)

                             # Parse leaf BIF strings "module.function/arity"
                             leaves =
                               Enum.map(leaf_strs, fn leaf_str ->
                                 case Regex.run(~r/^(.+)\.(.+)\/(\d+)$/, leaf_str) do
                                   [_, mod_str, func_str, arity_str] ->
                                     # Parse module name
                                     leaf_mod =
                                       case mod_str do
                                         "Elixir." <> rest ->
                                           Module.concat([rest])

                                         # For Elixir modules without prefix (e.g., "String.Unicode")
                                         # Check if starts with uppercase (Elixir convention)
                                         <<first::utf8, _rest::binary>> = name
                                         when first >= ?A and first <= ?Z ->
                                           Module.concat([name])

                                         # For Erlang modules (lowercase, e.g., "erlang", "ets")
                                         name ->
                                           String.to_atom(name)
                                       end

                                     leaf_func = String.to_atom(func_str)
                                     leaf_arity = String.to_integer(arity_str)
                                     {leaf_mod, leaf_func, leaf_arity}

                                   _ ->
                                     nil
                                 end
                               end)
                               |> Enum.reject(&is_nil/1)

                             {{module, func_atom, arity}, leaves}

                           _ ->
                             nil
                         end
                       end)
                       |> Enum.reject(&is_nil/1)
                     end)
                     |> Map.new()
                   else
                     %{}
                   end)

  @doc """
  Resolves a stdlib function to its leaf BIF(s) or bottommost Elixir functions.

  Recursively follows the resolution chain until reaching functions that are:
  1. In the effects map (bottommost Elixir functions), or
  2. Not in the resolution map (Erlang BIFs or truly bottommost)
  3. Resolve to themselves (self-cycles, treat as bottommost)

  Returns `{:ok, [leaf_mfas]}` if a resolution exists, or `:not_found` otherwise.

  ## Examples

      iex> resolve_to_leaves({File, :write!, 2})
      {:ok, [{:file, :write_file, 2}]}

      iex> resolve_to_leaves({String, :upcase, 1})
      {:ok, [{String.Unicode, :upcase, 3}, {String, :upcase_ascii, 1}]}
  """
  def resolve_to_leaves(mfa) do
    case Map.get(@resolution_map, mfa) do
      nil ->
        :not_found

      intermediate_mfas ->
        # Use a visited set to detect cycles
        do_resolve_to_leaves(intermediate_mfas, MapSet.new([mfa]))
    end
  end

  defp do_resolve_to_leaves(mfas, visited) do
    leaves =
      mfas
      |> Enum.flat_map(fn intermediate_mfa ->
        cond do
          # Already visited - skip it (cycle detected, won't give new info)
          MapSet.member?(visited, intermediate_mfa) ->
            []

          # If it's in the effects map, it's a leaf (bottommost)
          Map.has_key?(effects_map(), intermediate_mfa) ->
            [intermediate_mfa]

          # If it has further resolutions, recurse
          Map.has_key?(@resolution_map, intermediate_mfa) ->
            next_mfas = Map.get(@resolution_map, intermediate_mfa)
            next_visited = MapSet.put(visited, intermediate_mfa)
            {:ok, deeper_leaves} = do_resolve_to_leaves(next_mfas, next_visited)
            deeper_leaves

          # Otherwise, it's a private function or Erlang BIF - skip it
          # (Private functions aren't exported so we can't analyze them,
          #  treat as if they're bottommost and won't give us more info)
          true ->
            []
        end
      end)
      |> Enum.uniq()

    {:ok, leaves}
  end

  @doc """
  Checks if a function has a resolution mapping to leaf BIFs.
  """
  def has_resolution?(mfa) do
    Map.has_key?(@resolution_map, mfa)
  end

  @doc """
  Returns the resolution map for debugging.
  """
  def resolution_map do
    @resolution_map
  end

  # Check if an MFA is an exception struct construction function
  # These are generated by defexception and are always pure
  defp exception_struct_function?({module, function, arity}) when is_atom(module) do
    # Check if it's one of the standard exception struct functions
    is_struct_func = function in [:__struct__, :exception, :message] and arity in [0, 1, 2]

    # Check if the module is an exception module (ends with Error or is a known exception)
    is_exception_module =
      try do
        # Check if module exists and has Exception behaviour
        Code.ensure_loaded?(module) and function_exported?(module, :exception, 1)
      rescue
        _ -> false
      end

    is_struct_func and is_exception_module
  end

  defp exception_struct_function?(_), do: false

  # Check if an MFA is an Elixir special form that gets compiled away
  defp special_form?({Kernel, function, _arity}) do
    function in [
      # Bitstring/binary operators
      :<<>>,
      # String interpolation
      :<>,
      # Control flow (compiled to BIFs/BEAM instructions)
      :case,
      :if,
      :cond,
      :with,
      :for,
      :try,
      :receive,
      # Other special forms that get compiled to BIFs
      :%{},
      :%,
      :.,
      :&,
      :^,
      :=,
      :{},
      :__block__,
      :__aliases__,
      :fn
    ]
  end

  defp special_form?(_), do: false
end
